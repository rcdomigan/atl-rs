// Read Eval (PYO Print)
use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::mem::swap;
use std::path::Path;

use compile;
use compile::compile;
use lexical_scope::{scope, Environment};
use op_codes::BuildCode;
use parser;
use parser::{Parsed, Parser};
use types::Ast;
use vm;

pub struct REP {
    pub env: Environment,
    pub vm: vm::VM,
    code: BuildCode,
}

fn parse<T: Read>(input: T) -> Parsed {
    parser::from_read(input).unwrap().unwrap()
}

impl REP {
    pub fn new() -> REP {
        let mut env = Environment::new();
        let mut vm = vm::VM::new();
        let mut code = BuildCode::new();
        compile::wrap_primitives(&mut env, &mut code, &mut vm.state);
        REP {
            env,
            vm,
            code,
        }
    }

    pub fn load(&mut self, path: &Path) {
        match File::open(path) {
            Ok(file) => for expr in Parser::new(file) {
                // discard result of last iteration
                self.vm.clear_stack();
                match expr {
                    Ok(Parsed::Subex(ast)) => self.eval(&ast),
                    Ok(Parsed::Atom(_atom)) => (),
                    Err(err) => panic!("Parsing error: {}", err.description()),
                }
            },
            Err(err) => panic!("Can't load file {}: {}", path.display(), err.description()),
        }
    }

    pub fn run<T: Read>(&mut self, input: T) -> Option<usize> {
        match parse(input) {
            Parsed::Subex(ast) => {
                self.eval(&ast);
                self.vm.result()
            }
            Parsed::Atom(_) => None,
        }
    }

    pub fn run_str(&mut self, input: &str) -> Option<usize> {
        self.run(input.as_bytes())
    }

    pub fn compile(&mut self, unscoped: &Ast) -> Result<(), compile::CompilerError> {
        let scoped = scope(&mut self.env, &unscoped).unwrap();

        // Set the entry point so we skip over any previously defined
        // code.  We have to keep that code around since it defines
        // our function bodies, but we don't want to re-make the
        // closures etc.
        self.code.set_enter(self.code.len());

        let mut tmp = BuildCode::new();
        swap(&mut tmp, &mut self.code);
        self.code = compile(&scoped, tmp, &self.env.undefined)?;

        Ok(())
    }

    pub fn eval(&mut self, ast: &Ast) {
        self.compile(&ast).unwrap();

        let mut tmp = BuildCode::new();
        swap(&mut tmp, &mut self.code);
        let to_run = tmp.into_run();
        self.vm.run(&to_run);
        self.code = to_run.into_build();
    }
}

#[cfg(test)]
mod tests {
    use parser::Parsed;
    use rep::{parse, REP};
    use op_codes::Op;
    use primitives::equal;
    use types::AtlFn;

    // Check the code generated by parsing/scoping/compiling functions
    // from the core ATL test/assert function
    #[test()]
    fn compile_assert_eq() {
        let mut rep = REP::new();
        let expect_slot = rep.env.slots;
        let def_begins = rep.code.len();
        let expect_pc = def_begins + 1;

        rep.run("(define assert-eq (\\ (a b) (if (equal a b) 1 (exit 0))))".as_bytes());

        let expect = [
            Op::Jump(def_begins + 12),       // 0:
            Op::Fixnum(def_begins + 9),      // 1: address of alternate
            Op::Argument(1),                 // 2:
            Op::Argument(0),                 // 3:
            Op::Fixnum(2),                   // 4:
            Op::RustFunction(AtlFn(equal)),  // 5:
            Op::If,                          // 6:
            Op::Fixnum(1),                   // 7:
            Op::Jump(def_begins + 11),       // 8:
            Op::Fixnum(0),                   // 9:
            Op::Finish,                      // 10:
            Op::Return,                      // 11:
            Op::MakeClosure(expect_pc, 0),   // 12:
            Op::DefineGlobal(expect_slot)    // 13:
        ];

        assert!(
            rep.code.view().iter().skip(def_begins).eq(expect.iter()),
            "\ngot:  {:?}\nwant: {:?}",
            rep.code.view().iter().skip(def_begins).collect::<Vec<&Op>>(),
            expect,
        );

        if let Op::Jump(land_at) = rep.code.view()[0] {
            assert_eq!(land_at, def_begins);
        } else {
            panic!("Jump expected!");
        }

        match parse("(assert-eq 1 1)".as_bytes()) {
            Parsed::Subex(ast) => {
                rep.compile(&ast).expect("Error?!");
                let expect = [
                    Op::Jump(def_begins + 12),       // 0:
                    Op::Fixnum(def_begins + 9),      // 1: address of alternate
                    Op::Argument(1),                 // 2:
                    Op::Argument(0),                 // 3:
                    Op::Fixnum(2),                   // 4:
                    Op::RustFunction(AtlFn(equal)),  // 5:
                    Op::If,                          // 6:
                    Op::Fixnum(1),                   // 7:
                    Op::Jump(def_begins + 11),       // 8:
                    Op::Fixnum(0),                   // 9:
                    Op::Finish,                      // 10:
                    Op::Return,                      // 11:
                    Op::MakeClosure(expect_pc, 0),   // 12:
                    Op::DefineGlobal(expect_slot),   // 13: last op of first REP
                    Op::Fixnum(1),                   // 14: second rep
                    Op::Fixnum(1),                   // 15:
                    Op::Fixnum(2),                   // 16:
                    Op::DerefFn(expect_slot),        // 17:
                    Op::CallClosure,                 // 18:
                ];

                assert!(
                    rep.code.view().iter().skip(def_begins).eq(expect.iter()),
                    "\ngot:  {:?}\nwant: {:?}",
                    rep.code.view().iter().skip(def_begins).collect::<Vec<&Op>>(),
                    expect,
                )
            },
            _ => panic!(),
        }
    }

    #[test()]
    fn call_nested_closure() {
        let mut rep = REP::new();
        rep.run_str("(define add3 (\\ (a b c) (add2 (add2 a b) c)))");
        rep.run_str("(define foo (\\ (a b c) (sub2 (add3 a b c) c)))");
        assert_eq!(rep.run_str("(foo 3 5 7)"), Some(8));
        assert!(rep.vm.state.stack.is_empty());
    }

    #[test()]
    fn primitive_from_if() {
        let mut rep = REP::new();
        rep.run_str("(define add-double (\\ (a b) (add2 (add2 a b) (add2 a b))))");
        assert_eq!(rep.run_str("((if True add2 add-double) 3 2)"),
                   Some(5));
        assert_eq!(rep.run_str("((if False add2 add-double) 3 2)"),
                   Some(10));
    }
}
